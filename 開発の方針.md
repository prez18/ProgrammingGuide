# 開発の方針

CleanArchitectureをベースとして開発を行なう．    
個人開発であれ，小規模開発であれ，短期開発であれ，お試しのサンプルプロジェクトでもない限り，このアーキテクチャを利用することはMUSTとする．  
また，多くの恩恵が得られる点から`RxSwift`を採用し，Databindingを利用する．

## CleanArchitecture

利用する目的としては，以下を挙げる．

- 依存関係の明確化によるデグレの阻止
- 依存関係の明確化による類似処理定義の阻止
- 仕様変更及び追加に対して，変更容易な設計
- テスタブルな部分とそうでない部分の分離

アーキテクチャと言っているが，他のアーキテクチャのように登場するレイヤーが決まっているわけではなく，あくまで開発の方針を定義づけるものである．他のアーキテクチャとの併用も考えられる．  
巷で流行っている「UseCase」「Presenter」「Model」「Translator」「Repository」「DataStore」「Entity」「View」のような責務に必ずしも当てはめる，という話ではない．

CleanArchitectureの基本的な考え方を説明する．

複数のオブジェクトから依存されるオブジェクトに変更があった場合，当然ながら，依存している全てのオブジェクトにも影響が出る．  
変更により，一部の依存しているオブジェクトではデグレが発生するリスクが出てくる．または，デグレを恐れて下手に変更できない状態に追い込まれる．  
このことから，複数のオブジェクトから依存されるオブジェクトとしては，変更される可能性が低いものとなるようにする．  
また，変更される可能性の高いオブジェクトは，依存されるものを可能な限りなくすように設計をする．  
また，将来変更や処理の分岐が想定可能な処理に関しては，処理の差し替えが可能なように設計することを心がける．

DomainやUtilなど複数のオブジェクトから依存されるものに関しては，全員でReviewを実施する．これには以下の目的が挙げられる．

- このオブジェクトは後からの変更がしにくく，妥当な設計となっていることを十分に検討するため
- このオブジェクトに変更が発生した場合，その修正によるデグレーションが発生しないことを，十分に確認するため
- このオブジェクトは複数から依存されるが，その存在を周知できないと第三者が類似したオブジェクトを作成してしまうため
- このオブジェクトは複数から依存されるが，その存在を周知できないと，特にUtilの場合，利用されない恐れがあるため

## RxSwift/RxCocoa

RxSwiftを利用する目的としては，以下を挙げる．

- 並列処理や，処理の順番の制御が容易
- 一貫して同じ形式で記述が可能
- ネストが深くならない
- エラー処理がしやすい
- ErrorTrackerによりエラー処理を正常系から分離しやすい
- ActivityTrackerによりインジケータをより安全に制御しやすい
- DriverやSignalの利用により，DataBindingやMeinThreadでの動作処理がしやすい
- 連打対策や，処理のキャンセル(後がち，先がち)の制御が容易

## 実装の詳細

以下にCleanArchitecture + MVVM + RxSwift を組み合わせた実装の詳細を記述する．

### Domain

Domainの特徴は以下に挙げられる．

| 特徴               | 説明                                      |
| ------------------ | ----------------------------------------- |
| 依存するもの       | 他のエンティティやバリューオブジェクト          |
| 依存されるもの     | UseCase, ServiceのIF, RepositoryのIF                                 |
| 依存されるものの数 | 複数からの依存が想定される                                     |
| 作成する単位       | 業務ロジックとして最適な表現だと判断できればなんとでも                        |
| 禁止ワード         | 特定のフレームワークに依存する用語 |

エンティティまたはバリューオブジェクトは構造体として定義する．  
定義されるプロパティは必要がなければ`let`で表現する．  
単なるデータ構造ではないため，メソッドや計算型プロパティも定義される．  
識別されるべきオブジェクトなら，識別子を定義し，比較できるようにする．  
ここに属するオブジェクトは，複数のオブジェクトから依存される可能性がある．  
逆に限定的なオブジェクトからしか依存できないようなオブジェクトは定義されない．  
DomainはUseCaseからの依存しか受け付けない．間違ってもUtilityからの依存をしてはならない．また，Presenterからの依存も受け付けない．  
Domainとしては，他にもメソッドだけで構成されるServiceや後述のRepositoryのインタフェースが該当する．

```
// Entity
struct Content: Equatable {
    let id: String
    let contentType: ContentType
    let url: URL
}

extension Content: Equatable {
    static public func ==(lhs: Content, rhs: Content) -> Bool {
        return lhs.id == rhs.id
    }
}

// ValueObject
enum ContentType {
    case illust
    case novel
}

```

### UseCase

UseCaseの特徴は以下に挙げられる．

| 特徴               | 説明                                      |
| ------------------ | ----------------------------------------- |
| 依存するもの       | DomainLaylerに属するオブジェクト          |
| 依存されるもの     | Presenter                                 |
| 依存されるものの数 | 一つ                                      |
| 作成する単位       | イベントの単位ごと                        |
| 禁止ワード         | UI系の用語, キャッシュ, DB, API, Server, 特定のフレームワークに依存する用語 |

UseCaseはイベント単位で定義し，依存先は1箇所に限定され，再利用は行わない．  
同じ処理を実施するとしても，同じユースケースを複数箇所から利用することはしない．  
時間が経過することで依存先によって，仕様が変更されることは容易に想定できる．  
そのタイミングでUseCaseに呼び出し元に応じて分岐処理を加えると可読性低下する．  
戻り値のResultには，プロパティとしてDriver型のものが必要な数だけ指定される．  
なお，ResultにはEntityは含めず，必要な形式及びプロパティで構成されたオブジェクトで構成される
(慣例としてModelと呼称)．  
引数として，Driverにしたイベントを指定する．  
error処理はUsecCaseで実施するものとする．  
Parameterとしては，ユーザからの入力値が想定される．極力それ以外のデータは指定されない．

```
    protocol HogeUseCase {
        func act(trigger: Driver<Parameter>) -> Result
    }
    
    // ユーザからの入力値など
    struct HogeParameter {
            ...
        }
    
    struct HogeResult {
        // Driver群
        ...
    }
    
    struct HogeUseCase: HogeUseCase {
        func act(trigger: Driver<Parameter>) -> HogeResult {
            ...
        }
    }
    
```

### Presenter

Presenterの特徴は以下に挙げられる．

| 特徴               | 説明                                      |
| ------------------ | ----------------------------------------- |
| 依存するもの       | UseCase, Router          |
| 依存されるもの     | ViewController(Viewは含まれない)  |
| 依存されるものの数 | 一つ                                    |
| 作成する単位       | 原則としてViewControllerの数と一致．  |
| 禁止ワード         | 特定のフレームワークに依存する用語, UIKit |


Presenterでは，イベントを受け取り，ビューの状態を表現する．  
受け取ったイベントをUseCaseのトリガーとして渡し，処理結果や他のイベントを組み合わせて画面の状態を表現する．  
このとき，UseCaseの結果を別のUseCaseのトリガーに繋げるのは禁止する．  
これはPresenterが処理の手順(業務手順=UseCase)の責務を負ってしまうことを意味する．

また，画面遷移はrouterを呼び出して処理する．このとき，ビューの状態を表現している訳ではないため，  
ViewStateに繋げずにdriveする．

```

protocol HogePresenter {
    func transform(_ event: HogeEvent) -> HogeViewState
}

struct HogeEvent {
    let homeButtonTap: Driver<()>
    let fugaButtonDidTap: Driver<()>
}

struct HogeViewState {
    let piyoLabelText: Driver<String>
}

struct HogePresenter: HogePresenter {
    
    private let router: HogeRouter
    private let disposeBag = DisposeBag()
    
    private let fugaUseCase: FugaUseCase
    private let piyoUseCase: PiyoUseCase
    
    init(router: HogeRouter,
         fugaUseCase: FugaUseCase,
         piyoUseCase: PiyoUseCase) {
        self.router = router
        self.fugaUseCase = fugaUseCase
        self.piyoUseCase = piyoUseCase
    }
    
    func transform(_ event: HogeEvent) -> HogeViewState {
    　　 
       event.homeButtonTap.do { onNext: self.router.transitionToHome }.drive().disposed(by: self.disposeBag)
       
        // UseCaseのトリガーとしてイベントを渡し，UseCaseで処理した結果を受け取る．
        // UseCaseの結果を別のUseCaseのトリガーに繋げるのは禁止
        let fugaUseCaseResult = self.fugaUseCase.act(trigger: input.fugaButtonDidTap)
   
        // イベントやUseCaseで処理した結果を組み合わせてViewの状態を表現する．
        piyoLabelText = fugaUseCaseResult.message
        
        return HogeViewState(
            piyoLabelText: piyoLabelText
        )
    }
}

```

### ViewController

ViewControllerの特徴は以下に挙げられる．   
Viewに関してはPresenterは持たせない.

| 特徴               | 説明                                      |
| ------------------ | ----------------------------------------- |
| 依存するもの       | Presenter          |
| 依存されるもの     | - |
| 依存されるものの数 | -                             |
| 作成する単位       | 画面の単位と一致                       |
| 禁止ワード         | - |

```
final class HogeViewController: UIViewController {
    
    ...
    let presenter: HogePresenter!
    private let disposeBag = DisposeBag()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.setupUi()
        self.bindPresenter()
    }
    
    func setupUi() {
        // 状態を持たないテキストやカラー，Uiの生成はここで指定する．
    }
    
    func bindPresenter() {
        let event = HogePresenterEvent(
            // 画面表示中に発生するユーザイベントやアプリケーションイベントをセット
            hogeButtonTap: self.hogeButton.rx.tap.asDriver()
        )
        // transformメソッドから受け取ったViewの状態をUiとバインドする
        let viewState = self.presenter.transform(event)
        viewState.hogeButtonText.drive(self.hogeButton.rx.text).disposed(by: self.disposeBag)
        // 必要に応じて，Binderを利用する
    }
    
    // そのほかの処理はほどんど記載しない
    // viewWillAppearなどのイベントもrxで表現可能なため，bindPresenterでバインドする
    
}

```
#### 検討すべき点

ホーム画面のように多くのイベントやビューの状態を持つ場合，処理が肥大化する.


### Repository

Repositoryの特徴は以下に挙げられる．

| 特徴               | 説明                                      |
| ------------------ | ----------------------------------------- |
| 依存するもの       | RemoteDataStore, LocalDataStore, Entity          |
| 依存されるもの     | UseCase                                |
| 依存されるものの数 | 複数                               |
| 作成する単位       | 原則としてViewControllerの数と一致．                        |
| 禁止ワード         | Api, Database |

このレイヤーでは，データをRemoteまたはLocalで永続化制御を実施する．  
まや，特定の条件に従って，RemoteまたはLocalのどちらで処理を実施するかの判断もここで実施される．  
特定の条件としては，Remote取得時から30分が経過している場合はLocalのキャッシュを削除してRemoteから，そうでなければLocalからデータを取得する．

リポジトリのインタフェース上では，RemoteまたはLocalという表現は発生せず，特定の条件に関する表現(「キャッシュ」など)も含まれない．  
リポジトリの実装上では，上記の表現は含まれる．  
なお，Remote，Loacalという抽象的な表現に止めるべきであり，たとえば，APIやDatabase, より具体的なRealmやAlamofireという表現をするべきではない．  
LocalはDatabaseとは限らず，UserDafultsを用いるパターンもある．また，RemoteもApiだけでなくBluetooth接続されたデバイスに保存するパターンも想定される．

定義されるリポジトリインタフェースの単位は，永続化される集約エンティティの数と一致する．  
定義されるメソッド名としては，`create` `read` `update` `delete`などが挙げられる．

example
```
protocol HogeRepository {
    func create(_ hoge: Hoge) -> Observable<()>
    func read() -> Observable<Hoge>
    func delete(_ hoge: Hoge) -> Observable<()>
    func update(_ hoge: Hoge) -> Observable<()>
}

struct HogeRepositoryWithCash: HogeRepository {

    private let remoteDataStore: HogeRemoteDataStore

    private let localDataStore: HogeLocalDataStore
    
    init(remoteDataStore: HogeRemoteDataStore,
         localDataStore: HogeLocalDataStore) {
        self.remoteDataStore = remoteDataStore
        self.localDataStore = localDataStore
    }
    
    ...
    func read() -> Observable<Hoge> {
        ...
    }
    ...

}

```

###### 検討すべき点

必ずcrud全てのインタフェースを提供するべきかどうか検討するべきである．  
実態としてAPIを利用する場合，readに相当するApiはあっても，deleteに相当するApiないパターンがある．そうした場合，  
リポジトリとしてdeleteメソッドは実装はするが，実態としてはfatalErrorとするべきかもしれない．

readの場合，検索する条件が考えられるためどう実装するかは考えどころである．  
readの場合，データが必ず一つのみのパターンしか想定できないものは，インタフェースとして，コレクションで返すようにはしない．

### DataStore

DataStoreの特徴は以下に挙げられる．

| 特徴               | 説明                                      |
| ------------------ | ----------------------------------------- |
| 依存するもの       | DatabaseやApi, Networkなど          |
| 依存されるもの     | Repository                                |
| 依存されるものの数 | 複数(対応するリポジトリのインタフェースは単一)                               |
| 作成する単位       | 対応するリポジトリのインタフェースの数と一致                        |
| 禁止ワード         | キャッシュ |

基本的にリポジトリと同一のインタフェースとなる．  
必要に応じてNetworkの抽象的なプロトコルを切り出し，URLSessionやAlamofire, Moyaなど差し替えを容易にするなどが考えられる．  
永続化や通信に際の暗号化は，このレイヤーで実施する．

## 参考

- [Clean-Architecture-達人に学ぶソフトウェアの構造と設計](https://www.amazon.co.jp/Clean-Architecture-達人に学ぶソフトウェアの構造と設計-Robert-C-Martin/dp/4048930656/ref=sr_1_1?ie=UTF8&qid=1543145654&sr=8-1&keywords=クリーン+アーキテクチャ)
- https://github.com/sergdort/CleanArchitectureRxSwift

